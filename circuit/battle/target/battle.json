{"noir_version":"0.27.0+606ff4448571b0cfe4b92420c766c4239a4b23a0","hash":14186985169586894270,"abi":{"parameters":[{"name":"user_one_squad_hash","type":{"kind":"field"},"visibility":"public"},{"name":"user_one_squad","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"user_two_squad","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"battle_result","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"battle_result":[{"start":7,"end":8}],"user_one_squad":[{"start":1,"end":4}],"user_one_squad_hash":[{"start":0,"end":1}],"user_two_squad":[{"start":4,"end":7}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"ndjRqtswDAbgd8l1LyTLkq2+ythFd9ZBofQcTrvBKH33tawOm6M0/LmLib+Q8AtH9nU4vr/tLof303nYXgcatl+uw/ljd3qMzpfd52XYJs2bYX/6fr/yfNsMPw7H/bDN5baZTqVKbS5zHScL3b5uBo6eLlSeQrT++/Q7SBHIZk+Qq3dAUJBRoCgwFBQUVBQ4CphgwbCYCVub+L/2HkJgEcft9Sk0cS8UFgaLAosKC0dFIlgwLBIsBBYzmZdRWC8UFva6EgNRYBFmrtLWW1XphaNCCBYMiwQLgUWGhcLCYFFgEWeefBT9H1McFZkWKnEqGBZx5s5PYdyv1FlgkWGhsDBYFFhUWDgqlGDBsJjJnEYxaa0EFmHmlqSJ3K+iqrAwWBRYVFg4KoxgwbBIsBBYzGSemtC+AzCFhS1U4lQUWMSZa1tFrfSrqDkqCsGCYZFgIbDIsFBYGCwKLGYyb/trq30HUBwVlRYqcSoYFmHmxVoXXrz0QmARZl7E5oXCIsy8UvvymiZ77QKL+vqtAuGo8DDzWlvX59xXojMswsyrlnkhsAgz99S6DFfqhcLCFt5qKgoswsyZuP1ymLL2xnHDRDGyliMzpQniNSiMn9O4s+BkUyRrUF6DdA2yNSisBhZu5cAyqQemugb5ChQf1S2hONw8Hs1ynvRhHB+/vUL3wa/d52H37bh/nDY/7v08vbXD5/vw8vvj753bHw==","file_map":{"30":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(sha256)]\n// docs:start:sha256_slice\npub fn sha256_slice(input: [u8]) -> [u8; 32]\n// docs:end:sha256_slice\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s_slice\npub fn blake2s_slice(input: [u8]) -> [u8; 32]\n// docs:end:blake2s_slice\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3_slice\npub fn blake3_slice(input: [u8]) -> [u8; 32]\n// docs:end:blake3_slice\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n// docs:start:pedersen_commitment_slice\npub fn pedersen_commitment_slice(input: [Field]) -> PedersenPoint {\n    pedersen_commitment_with_separator_slice(input, 0)\n}\n// docs:end:pedersen_commitment_slice\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator_slice(input: [Field], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_commitment_with_separator_slice(input: [Field], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator_slice(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n// docs:start:pedersen_hash_slice\npub fn pedersen_hash_slice(input: [Field]) -> Field\n// docs:end:pedersen_hash_slice\n{\n    pedersen_hash_with_separator_slice(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator_slice(input: [Field], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut inputs_as_bytes = &[];\n\n    for input in inputs {\n        let input_bytes = input.to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s_slice(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(keccak256)]\n// docs:start:keccak256_slice\npub fn keccak256_slice(input: [u8], message_size: u32) -> [u8; 32]\n// docs:end:keccak256_slice\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self]);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self.lo as Field, self.hi as Field]);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"47":{"source":"use dep::std;\n\n//\n// Circuit that validates battle\n//\nfn main(user_one_squad_hash: pub Field, user_one_squad: [Field; 3], user_two_squad: pub [Field; 3], battle_result: pub Field) {\n    // Check user one squad hash\n    let user_one_squad_computed_hash = std::hash::pedersen_hash(user_one_squad);\n    assert(user_one_squad_computed_hash == user_one_squad_hash, \"User one's squad hash integrity check failed\");\n\n    // Calculate health \n    let mut user_one_health = (user_one_squad[0] as u8) * 6 + (user_one_squad[1] as u8) * 4 + (user_one_squad[2] as u8) * 2;\n    let mut user_two_health = (user_two_squad[0] as u8) * 6 + (user_two_squad[1] as u8) * 4 + (user_two_squad[2] as u8) * 2;\n\n    // Calculate attack\n    let user_one_attack = (user_one_squad[0] as u8) * 1 + (user_one_squad[1] as u8) * 2 + (user_one_squad[2] as u8) * 3;\n    let user_two_attack = (user_two_squad[0] as u8) * 1 + (user_two_squad[1] as u8) * 2 + (user_two_squad[2] as u8) * 3;\n\n    // Calculate health after attack\n    user_one_health = user_one_health - user_two_attack;\n    user_two_health = user_two_health - user_one_attack;\n\n    // Calculate battle result (0 draw, 1 - user one won, 2 - user two won)\n    let mut computed_battle_result = 0;\n    if (user_one_health > user_two_health) {\n        computed_battle_result = 1;\n    } \n    if (user_one_health < user_two_health) {\n        computed_battle_result = 2;\n    }\n    assert(computed_battle_result == battle_result, \"Battle result incorrect\");\n}\n\n#[test]\nfn test_draw() {\n    let user_one_squad = [4, 1, 5];\n    let user_one_squad_hash = std::hash::pedersen_hash(user_one_squad);\n    let user_two_squad = [4, 1, 5];\n    let battle_result = 0;\n    main(user_one_squad_hash, user_one_squad, user_two_squad, battle_result);\n}\n\n#[test]\nfn test_user_one_win() {\n    let user_one_squad = [4, 1, 5];\n    let user_one_squad_hash = std::hash::pedersen_hash(user_one_squad);\n    let user_two_squad = [3, 2, 5];\n    let battle_result = 1;\n    main(user_one_squad_hash, user_one_squad, user_two_squad, battle_result);\n}\n\n#[test]\nfn test_user_two_win() {\n    let user_one_squad = [4, 1, 5];\n    let user_one_squad_hash = std::hash::pedersen_hash(user_one_squad);\n    let user_two_squad = [5, 2, 3];\n    let battle_result = 2;\n    main(user_one_squad_hash, user_one_squad, user_two_squad, battle_result);\n}\n","path":"/mnt/c/Users/kiv1n/Workspace/web3goals/crypto-battlefield-prototype/circuit/battle/src/main.nr"}},"names":["main"]}